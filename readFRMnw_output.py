import sys

nw_out_read = open("nw_output.txt",'r')
count = 0
possible_alignemnts = []
c = nw_out_read.readline()
align_tuple = ["",""]
while 1:
	c = nw_out_read.readline()
	if not c:
		break
	if c[0] == 'A' or c[0] == 'T' or c[0]== 'G' or c[0] == 'C' or c[0]=='_' :
		count = count + 1
		align_tuple[count - 1] = c.replace("\n","")
		#print("Seq ",count," : : ",c)
		if count == 2:
			possible_alignemnts.append(tuple(align_tuple))
			count = 0	
nw_out_read.close()
#print("Alignments : ",possible_alignemnts)
#creating a dictionary of tandem repeats
#Generated by perf_ssr package 
"""Usage : perf -i file_name(in fasta format) -u 2
output will be in file_name_perf.tsv file  """ 
repeat_infor = {1 : [] , 2 : [] , 3 : [] , 4 : [] , 5 : [] , 6 : [] }
infor = {}
perf_read_fd = open("d1_perf.tsv",'r')
while 1:
	c = perf_read_fd.readline()
	if not c:
		break
	splits = c.split("\t")
	"""repeat_infor is a tuple that contains 
	 1. Starting index of the repeat
	 2. End index of the repeat
	 3. Total repeat length
	 4. No of times basse motif is repeated
	 5. Motif"""
	record = (int(splits[1]),int(splits[2]),int(splits[6]),splits[7].replace("\n",""))
	repeat_infor[len(record[3])].append(record)
	infor[record[0]] = record	
#print(repeat_infor)
perf_read_fd.close()	

def in_tandem_repeat_region(index):
	for i,j in infor.items():
		if index >= j[0] and index < j[1]:
			return (True,j)
	return (False,-1)		
#trying to score the alignments
score = []
pmutation = []
for indx in range(len(possible_alignemnts)):
	#print the mis matches
	pm = 0
	ins = 0
	insr_list = []
	deltn = 0
	deltn_list = []
	seq1 = possible_alignemnts[indx][0]
	seq2 = possible_alignemnts[indx][1]
	pmut = []
	#print("seq1 :",seq1)
	#print("seq2 :",seq2)
	print("\n")
	for i in range(len(seq1)):
		if seq1[i] != seq2[i] :
			if seq1[i] != '_' and seq2[i] != '_' :
				print("Point mutation at ",i)
				pm = pm + 1
				pmut.append(i)
			elif seq1[i] == '_':
				print("Insertion at index ",i)
				ins = ins + 1
				insr_list.append(i)
			else:
				print("Deletion at index ",i)
				deltn = deltn + 1
				deltn_list.append(i)
	scr = 0
	if ins > 0:
		prev = 0
		for i in insr_list:
			stat = in_tandem_repeat_region(i)

			if stat[0]:
				if i == prev + 1:
					if prev == 0:
						scr = scr + 5

					else:
						scr = scr + 10
				else:
					scr = scr + 5		
			else:
				#print("Not a tandem repeat insertion : ",i," :: ",prev)
				if i == prev + 1:
					#print("\nin insertion  but still continued\n")
					scr = scr + 10
				else:			
					scr = scr + 1
				#scr = scr + 1	
			prev = i		

	if deltn > 0:
		prev = 0
		for i in deltn_list:
			stat = in_tandem_repeat_region(i)
			if stat[0]:
				if i == prev + 1:
					if prev == 0:
						scr = scr + 5

					else:
						scr = scr + 10
				else:
					scr = scr + 5		
			else:
				#print("Not a tandem repeat deletion : ",i," :: ",prev)
				if i == prev + 1:
					#print("\nNot in deletion  but still continued\n")
					scr = scr + 10
				else:			
					scr = scr + 1
			prev = i
	score.append((scr,indx))
	pmutation.append(pmut)

print(score)
#now ordering the alignments based on score
#one with the highest score could be the possible alignment

sys.stdout = open("Frame_Shift.txt",'w')
#print(score)
print(" A \'_\' in the first sequence implies insertion took place")
print(" A \'_\' in the second sequence implies deletion took place")
print("\n=============================================================\n")

score.sort(reverse = True)

for a_tuple in score:
	print(possible_alignemnts[a_tuple[1]][0])
	print(possible_alignemnts[a_tuple[1]][1])
	print("Score : ",a_tuple[0])
	print("Point mutations at index/indices: ", pmutation[a_tuple[1]])
	print("\n==================================\n")

				

					
